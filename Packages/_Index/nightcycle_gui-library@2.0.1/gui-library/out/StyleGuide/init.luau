--strict
-- this script was generated by nightcycle/style-guide, do not manually edit

-- Services
local RunService = game:GetService("RunService")

-- Packages
local Maid = require(script:WaitForChild("Packages"):WaitForChild("Maid"))
local ColdFusion = require(script:WaitForChild("Packages"):WaitForChild("ColdFusion"))
local CurveUtil = require(script:WaitForChild("Packages"):WaitForChild("CurveUtil"))
local ServiceProxy = require(script:WaitForChild("Packages"):WaitForChild("ServiceProxy"))

-- Modules
local Package = script.Parent
assert(Package)
local PseudoEnum = require(Package:WaitForChild("PseudoEnum"))

-- Types
export type ContrastStandardType = PseudoEnum.ContrastStandardType
export type GuiAlignmentType = PseudoEnum.GuiAlignmentType
export type GuiCategoryType = PseudoEnum.GuiCategoryType
export type GuiColorPalette = PseudoEnum.GuiColorPalette
export type GuiDensityModifier = PseudoEnum.GuiDensityModifier
export type GuiThemeType = PseudoEnum.GuiThemeType
export type GuiTypography = PseudoEnum.GuiTypography

type State<T> = ColdFusion.State<T>
type ValueState<T> = ColdFusion.ValueState<T>
type CanBeState<T> = (State<T> | T)
type Maid = Maid.Maid
-- Constants
local ABS_MIN_TEXT_SIZE = 8
local LUM_LIMIT = 0.03928
local LUM_DENOM = 12.92
local LUM_OFFSET = 0.055
local LUM_OFFSET_DENOM = 1.055
local R_WEIGHT = 0.2126
local G_WEIGHT = 0.7152
local B_WEIGHT = 0.0722
local L_EXP = 2.4
local MIN_HEX_DIFFERENCE = 100 / 255
local BLACK_COLOR = Color3.fromHex("#000")
local WHITE_COLOR = Color3.fromHex("#FFF")

local GAIN_COLOR = Color3.fromHex("#29c000")
local LOSS_COLOR = Color3.fromHex("#f30025")
local WARN_COLOR = Color3.fromHex("#ff930d")
local ERROR_COLOR = Color3.fromHex("#ff0000")
local PRIMARY_DEFAULT_COLOR = Color3.fromHex("#2b7bff")
local SECONDARY_DEFAULT_COLOR = Color3.fromHex("#ffd398")
local TERTIARY_DEFAULT_COLOR = Color3.fromHex("#00cbfc")
local BACKGROUND_DEFAULT_COLOR = Color3.fromHex("#c5dcff")

local VALUE_RANGE = 0.3
local VALUE_BUFFER = 0.05
local SATURATION_RANGE = 0.1
local CONTRAST_STANDARD_RATIOS: { [ContrastStandardType]: number } = {
	Default = 4.5,
	LargeText = 3,
	Incidental = 0,
	Logotype = 0,
}

local ELEVATION_DATA = {
	0,
	1,
	3,
	5,
	7,
	12,
}

local STYLE_VARIANT_COUNTS = {
	Primary = #ELEVATION_DATA,
	Secondary = #ELEVATION_DATA,
	Tertiary = #ELEVATION_DATA,
	Surface = #ELEVATION_DATA,
	Warning = 1,
	Error = 1,
	Loss = #ELEVATION_DATA,
	Gain = #ELEVATION_DATA,
	Dark = #ELEVATION_DATA,
	Light = #ELEVATION_DATA,
}

-- modifiers
type Typography = {
	Font: Font,
	Scale: number,
	TextWrapped: boolean,
}

type Paddings = {
	[GuiDensityModifier]: number,
}

local Typography: { [GuiTypography]: Typography } = {
	Headline1 = {
		Font = Font.fromName("Highway", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
		Scale = 6.0,
		TextWrapped = true,
	},
	Headline2 = {
		Font = Font.fromName("Highway", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
		Scale = 4.0,
		TextWrapped = true,
	},
	Headline3 = {
		Font = Font.fromName("Highway", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
		Scale = 3.5,
		TextWrapped = false,
	},
	Headline4 = {
		Font = Font.fromName("Highway", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
		Scale = 3.0,
		TextWrapped = false,
	},
	Headline5 = {
		Font = Font.fromName("Highway", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
		Scale = 2.75,
		TextWrapped = false,
	},
	Headline6 = {
		Font = Font.fromName("Highway", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
		Scale = 2.5,
		TextWrapped = false,
	},
	Subtitle1 = {
		Font = Font.fromName("Highway", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
		Scale = 2.25,
		TextWrapped = false,
	},
	Subtitle2 = {
		Font = Font.fromName("Highway", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
		Scale = 2.0,
		TextWrapped = false,
	},
	Button = {
		Font = Font.fromName("Gotham", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
		Scale = 1.875,
		TextWrapped = false,
	},
	Body1 = {
		Font = Font.fromName("Gotham", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
		Scale = 1.5,
		TextWrapped = false,
	},
	Body2 = {
		Font = Font.fromName("Gotham", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
		Scale = 1.375,
		TextWrapped = false,
	},
	Caption = {
		Font = Font.fromName("Ubuntu", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
		Scale = 1.125,
		TextWrapped = false,
	},
	Overline = {
		Font = Font.fromName("Ubuntu", Enum.FontWeight.Bold, Enum.FontStyle.Normal),
		Scale = 1.0,
		TextWrapped = false,
	},
}

local Paddings: Paddings = {
	Default = 1,
	High = 0.75,
	Low = 1.5,
}

export type StyleGuide = {
	__index: StyleGuide,
	_IsAlive: boolean,
	_Maid: Maid,
	_MinimumPaddingSize: State<number>,
	_Typography: State<{ [GuiTypography]: Typography }>,
	_Paddings: State<{ [GuiDensityModifier]: number }>,
	_Palette: State<{ [GuiColorPalette]: Color3 }>,
	_Colors: { [GuiColorPalette]: State<Color3> },
	_ContrastColors: { [GuiColorPalette]: State<Color3> },
	_FullContrastColors: { [GuiColorPalette]: { [GuiColorPalette]: State<Color3> } },
	_TextSizeStates: { [GuiThemeType]: State<number> },
	_TextWrapStates: { [GuiThemeType]: State<boolean> },
	_TextFontStates: { [GuiThemeType]: State<Font> },
	_PaddingStates: { [GuiDensityModifier]: State<UDim> },
	_AbsoluteBackground: State<Color3>,

	Scale: ValueState<number>,
	IsDarkMode: ValueState<boolean>,
	Primary: ValueState<Color3>,
	Secondary: ValueState<Color3>,
	Tertiary: ValueState<Color3>,
	Background: ValueState<Color3>,
	MinimumTextSize: State<number>,

	CornerRadius: State<UDim>,
	BorderSizePixel: State<number>,
	ViewportSize: State<Vector2>,

	Destroy: (self: StyleGuide) -> nil,
	GetPadding: (StyleGuide, CanBeState<GuiDensityModifier>) -> State<UDim>,
	GetTextSize: (StyleGuide, CanBeState<GuiTypography>) -> State<number>,
	GetTextWrapped: (StyleGuide, CanBeState<GuiTypography>) -> State<boolean>,
	GetFont: (StyleGuide, CanBeState<GuiTypography>) -> State<Font>,
	GetColor: (StyleGuide, CanBeState<GuiColorPalette>) -> State<Color3>,
	GetContrastColor: (StyleGuide, CanBeState<GuiColorPalette>, CanBeState<GuiColorPalette>?) -> State<Color3>,

	new: (config: { [string]: any }?) -> StyleGuide,
	init: (maid: Maid) -> nil,
	getReadableColor: (color: Color3, background: Color3, contrastStandard: ContrastStandardType?) -> Color3,
	checkContrast: (color: Color3, background: Color3, contrastStandard: ContrastStandardType) -> boolean,
	getContrastRatio: (color: Color3, background: Color3) -> number,
	[any]: nil,
}
local Guide: StyleGuide = {} :: any
Guide.__index = Guide

function Guide:Destroy()
	self._Maid:Destroy()
	local t: any = self
	for k, v in pairs(t) do
		t[k] = nil
	end
	setmetatable(t, nil)
	return nil
end

local currentGuide: StyleGuide

function Guide.new(): StyleGuide
	local maid = Maid.new()
	local _fuse = ColdFusion.fuse(maid)
	local _import = _fuse.import
	local _new = _fuse.new

	local _Computed = _fuse.Computed
	local _Value = _fuse.Value

	local Primary = _Value(PRIMARY_DEFAULT_COLOR)
	local Secondary = _Value(SECONDARY_DEFAULT_COLOR)
	local Tertiary = _Value(TERTIARY_DEFAULT_COLOR)
	local Background = _Value(BACKGROUND_DEFAULT_COLOR)
	local IsDarkMode = _Value(true)
	local AbsoluteBackground = _Computed(function(background: Color3, isDarkMode: boolean)
		local h, s, v = background:ToHSV()
		if isDarkMode then
			background = Color3.fromHSV(h, s, 0.025 + 0.025 * v)
		end
		return background
	end, Background, IsDarkMode)

	local ViewportSize = _Value(workspace.CurrentCamera.ViewportSize)
	maid:GiveTask(RunService.RenderStepped:Connect(function()
		ViewportSize:Set(workspace.CurrentCamera.ViewportSize)
	end))

	local Palette = _Computed(
		function(
			primary: Color3,
			secondary: Color3,
			tertiary: Color3,
			background: Color3
		): { [PseudoEnum.GuiColorPalette]: Color3 }
			local palette = {}

			local function getBrightness(elevation: number)
				local maxElevation = ELEVATION_DATA[#ELEVATION_DATA]
				return (elevation / maxElevation) ^ 0.5
			end

			for key: string, count in pairs(STYLE_VARIANT_COUNTS) do
				for i = 1, count do
					local enum: PseudoEnum.GuiColorPalette? =
						PseudoEnum.GuiColorPalette[(key .. if count == 1 then "" else tostring(i)) :: any]
					assert(enum)

					local h: number, s: number, v: number
					if key == "Surface" then
						h, s, v = background:ToHSV()
					elseif key == "Primary" then
						h, s, v = primary:ToHSV()
					elseif key == "Secondary" then
						h, s, v = secondary:ToHSV()
					elseif key == "Tertiary" then
						h, s, v = tertiary:ToHSV()
					elseif key == "Warning" then
						h, s, v = WARN_COLOR:ToHSV()
					elseif key == "Loss" then
						h, s, v = LOSS_COLOR:ToHSV()
					elseif key == "Gain" then
						h, s, v = GAIN_COLOR:ToHSV()
					elseif key == "Dark" then
						h, s, v = BLACK_COLOR:ToHSV()
					elseif key == "Light" then
						h, s, v = WHITE_COLOR:ToHSV()
					else
						h, s, v = ERROR_COLOR:ToHSV()
					end

					-- gets elevation level
					local top = {
						Saturation = math.max(0, s - SATURATION_RANGE),
						Value = math.min(1 - VALUE_BUFFER, v + VALUE_RANGE),
					}
					local bottom = {
						Saturation = math.min(1, top.Saturation + SATURATION_RANGE),
						Value = math.max(VALUE_BUFFER, top.Value - VALUE_RANGE),
					}
					top.Saturation = bottom.Saturation - SATURATION_RANGE
					top.Value = bottom.Value + VALUE_RANGE

					local brightness = getBrightness(ELEVATION_DATA[i])

					palette[enum] = Color3.fromHSV(
						h,
						CurveUtil.lerp(bottom.Saturation, top.Saturation, brightness),
						CurveUtil.lerp(bottom.Value, top.Value, brightness)
					)
				end
			end
			return palette
		end,
		Primary,
		Secondary,
		Tertiary,
		AbsoluteBackground
	)

	local Scale = _Value(1)
	local MinimumTextSize = _Computed(function(vSize: Vector2, scale: number): number
		return math.max(math.ceil(0.0075 * vSize.Y * scale), math.ceil(ABS_MIN_TEXT_SIZE * scale))
	end, ViewportSize, Scale:Tween())

	local self: StyleGuide = setmetatable({}, Guide) :: any
	self._IsAlive = true
	self.Primary = Primary
	self.Secondary = Secondary
	self.Tertiary = Tertiary
	self.IsDarkMode = IsDarkMode
	self.Background = Background
	self._AbsoluteBackground = AbsoluteBackground
	self.Scale = Scale
	self.ViewportSize = ViewportSize
	self.CornerRadius = _Computed(function(minTextSize: number)
		minTextSize = math.max(math.round(minTextSize * 0.5), 1) :: number
		return UDim.new(0, minTextSize)
	end, MinimumTextSize)
	self.BorderSizePixel = _Computed(function(minTextSize: number)
		return math.max(math.round(minTextSize * 0.25), 1)
	end, MinimumTextSize)
	self._Maid = maid
	self._Paddings = _Value(Paddings)
	self._Typography = _Value(Typography)
	self._MinimumPaddingSize = _Computed(function(minTextSize: number): number
		return math.max(math.ceil(minTextSize * 0.75), 1)
	end, MinimumTextSize)
	self._MinimumTextSize = MinimumTextSize
	self._Palette = Palette
	self._Colors = {}
	self._ContrastColors = {}
	self._FullContrastColors = {}
	self._TextSizeStates = {}
	self._TextWrapStates = {}
	self._TextFontStates = {}
	self._PaddingStates = {}

	for i, enumItem in ipairs(PseudoEnum.getEnumItems("GuiColorPalette")) do
		self._Colors[enumItem] = _Computed(function(palette)
			if not palette then
				return Color3.new(0, 0, 0)
			end
			return palette[enumItem] or Color3.new(0, 0, 0)
		end, Palette):Tween(0.5)
	end
	for i, enumItem in ipairs(PseudoEnum.getEnumItems("GuiColorPalette")) do
		self._ContrastColors[enumItem] = _Computed(function(background: Color3)
			return Guide.getReadableColor(Color3.fromHSV(0, 0, 0.5), background)
		end, self._Colors[enumItem])
		self._FullContrastColors[enumItem] = {}
		for j, backEnumItem in ipairs(PseudoEnum.getEnumItems("GuiColorPalette")) do
			self._FullContrastColors[enumItem][backEnumItem] = _Computed(function(front: Color3, background: Color3)
				return Guide.getReadableColor(front, background)
			end, self._Colors[enumItem], self._Colors[backEnumItem])
		end
	end

	_Computed(function(typography: PseudoEnum.GuiTypography, minTextSize: number)
		for enumItem: PseudoEnum.GuiThemeType, data: Typography in pairs(typography) do
			local TSS: any = self._TextSizeStates[enumItem] or _Value(nil)
			local TextStateSize: ValueState<number> = TSS
			TextStateSize:Set(math.ceil(data.Scale * minTextSize))
			self._TextSizeStates[enumItem] = TextStateSize

			local TWS: any = self._TextWrapStates[enumItem] or _Value(nil)
			local TextWrapState: ValueState<boolean> = TWS
			TextWrapState:Set(data.TextWrapped)
			self._TextWrapStates[enumItem] = TextWrapState

			local TFS: any = self._TextFontStates[enumItem] or _Value(nil)
			local TextFontState: ValueState<Font> = TFS
			TextFontState:Set(data.Font)
			self._TextFontStates[enumItem] = TextFontState
		end
		return nil
	end, self._Typography, MinimumTextSize)

	_Computed(function(paddings: Paddings, minTextSize: number)
		for enumItem, val: number in pairs(paddings) do
			local PS: any = self._PaddingStates[enumItem] or _Value(nil)
			local PaddingState: ValueState<UDim> = PS
			PaddingState:Set(UDim.new(0, math.ceil(val * minTextSize)))
			self._PaddingStates[enumItem] = PaddingState
		end
		return nil
	end, self._Paddings, MinimumTextSize)

	setmetatable(self, Guide)

	currentGuide = self :: any
	return self :: any
end

function handleDynamicEnum<T, G>(pseudo: CanBeState<T>, options: { [T]: State<G> }): State<G>
	local state = pseudo :: any

	if type(state) == "string" then
		return options[state :: any]
	else
		return ColdFusion.Computed(function(key: T): G
			local vals = {}
			for k, v: State<G> in pairs(options) do
				vals[k] = v:Get()
			end
			return vals[key]
		end, state)
	end
end
function handleDoubleDynamicEnum<T, G>(
	pseudo1: CanBeState<T>,
	pseudo2: CanBeState<T>,
	options: { [T]: { [T]: State<G> } }
): State<G>
	local state1 = pseudo1 :: any
	local state2 = pseudo2 :: any
	if typeof(state1) == "string" and typeof(state2) == "string" then
		return options[state1 :: any][state2 :: any]
	elseif typeof(state1) ~= "string" and typeof(state2) ~= "string" then
		return ColdFusion.Computed(function(key1: T, key2: T): G
			local vals = {}
			for k1, v1: { [T]: State<G> } in pairs(options) do
				vals[k1] = {}
				for k2, v2: State<G> in pairs(v1) do
					vals[k1][k2] = v2:Get()
				end
			end
			return vals[key1][key2]
		end, state1, state2)
	elseif typeof(state1) ~= "string" then
		return ColdFusion.Computed(function(key1: T): G
			local vals = {}
			for k1, v1: { [T]: State<G> } in pairs(options) do
				vals[k1] = {}
				for k2, v2: State<G> in pairs(v1) do
					vals[k1][k2] = v2:Get()
				end
			end
			return vals[key1][state2]
		end, state1)
	elseif typeof(state2) ~= "string" then
		return ColdFusion.Computed(function(key2: T): G
			local vals = {}
			for k1, v1: { [T]: State<G> } in pairs(options) do
				vals[k1] = {}
				for k2, v2: State<G> in pairs(v1) do
					vals[k1][k2] = v2:Get()
				end
			end
			return vals[state1][key2]
		end, state2) :: any
	end
	error("Bad params")
end

function Guide:GetPadding(guiDensityModifier: CanBeState<PseudoEnum.GuiDensityModifier>): State<UDim>
	assert(guiDensityModifier ~= nil, "Bad GuiDensityModifier")
	return handleDynamicEnum(guiDensityModifier, self._PaddingStates)
end

function Guide:GetTextSize(guiTypography: CanBeState<PseudoEnum.GuiTypography>): State<number>
	assert(guiTypography ~= nil, "Bad GuiTypography")
	return handleDynamicEnum(guiTypography, self._TextSizeStates)
end

function Guide:GetTextWrapped(guiTypography: CanBeState<PseudoEnum.GuiTypography>): State<boolean>
	assert(guiTypography ~= nil, "Bad GuiTypography")
	return handleDynamicEnum(guiTypography, self._TextWrapStates)
end
function Guide:GetFont(guiTypography: CanBeState<PseudoEnum.GuiTypography>): State<Font>
	assert(guiTypography ~= nil, "Bad GuiTypography")
	return handleDynamicEnum(guiTypography, self._TextFontStates)
end

function Guide:GetColor(guiColorPalette: CanBeState<PseudoEnum.GuiColorPalette>): State<Color3>
	assert(guiColorPalette ~= nil, "Bad GuiColorPalette")
	return handleDynamicEnum(guiColorPalette, self._Colors)
end

function Guide:GetContrastColor(
	backColorPalette: CanBeState<PseudoEnum.GuiColorPalette>,
	goalColorPalette: CanBeState<PseudoEnum.GuiColorPalette>?
): State<Color3>
	assert(backColorPalette ~= nil, "Bad GuiColorPalette")
	if goalColorPalette == nil then
		return handleDynamicEnum(backColorPalette, self._ContrastColors)
	else
		assert(goalColorPalette ~= nil)
		return handleDoubleDynamicEnum(goalColorPalette, backColorPalette, self._FullContrastColors)
	end
end

function Guide.getContrastRatio(foreground: Color3, background: Color3): number
	local function getRelativeLuminance(color: Color3): number
		local function solveSpace(v: number): number
			if v < LUM_LIMIT then
				return v / LUM_DENOM
			else
				return ((v + LUM_OFFSET) / LUM_OFFSET_DENOM) ^ L_EXP
			end
		end
		return R_WEIGHT * solveSpace(color.R) + G_WEIGHT * solveSpace(color.G) + B_WEIGHT * solveSpace(color.B)
	end

	local _fH, _fS, fV = foreground:ToHSV()
	local _bH, _bS, bV = background:ToHSV()

	local fLum = getRelativeLuminance(foreground)
	local bLum = getRelativeLuminance(background)

	local lighterRelativeLuminance: number
	local darkerRelativeLuminance: number
	if fV < bV then
		lighterRelativeLuminance = bLum
		darkerRelativeLuminance = fLum
	else
		lighterRelativeLuminance = fLum
		darkerRelativeLuminance = bLum
	end

	return (lighterRelativeLuminance + 0.05) / (darkerRelativeLuminance + 0.05)
end

function Guide.checkContrast(
	color: Color3,
	background: Color3,
	contrastStandard: PseudoEnum.ContrastStandardType
): boolean
	local minRatio = CONTRAST_STANDARD_RATIOS[contrastStandard]
	local ratio = Guide.getContrastRatio(color, background)
	return ratio >= minRatio
end

-- https://github.com/alex-page/a11ycolor/blob/main/index.js
function Guide.getReadableColor(
	color: Color3,
	background: Color3,
	contrastStandard: PseudoEnum.ContrastStandardType?
): Color3
	contrastStandard = PseudoEnum.ContrastStandardType.Default
	assert(contrastStandard ~= nil)

	-- Check the ratio straight away, if it passes return the value as hex
	if Guide.checkContrast(color, background, contrastStandard) then
		return color
	end

	-- Ratio didn't pass so we need to find the nearest color
	local isBlackContrast = Guide.checkContrast(BLACK_COLOR, background, contrastStandard)
	local isWhiteContrast = Guide.checkContrast(WHITE_COLOR, background, contrastStandard)

	local cH, cS, cV = color:ToHSV()
	local minValue = 0
	local maxValue = 1
	local isDarkColor = false

	-- If black and white both pass on the background
	if isBlackContrast and isWhiteContrast then
		-- Change the min lightness if the color is light
		if cV >= 0.5 then
			minValue = cV
		else -- Change the max lightness if the color is dark
			maxValue = cV
			isDarkColor = true
		end
	elseif isBlackContrast then -- If our colour passes contrast on black
		maxValue = cV
		isDarkColor = true
	else -- Colour doesn't meet contrast pass on black
		minValue = cV
	end

	-- The color to return
	local finalColor: Color3?

	-- Binary search until we find the colour that meets contrast
	local prevColor: Color3?
	while not finalColor do
		local midValue = (minValue + maxValue) / 2
		local midColor = Color3.fromHSV(cH, cS, midValue)
		if Guide.checkContrast(midColor, background, contrastStandard) then
			if maxValue - minValue <= MIN_HEX_DIFFERENCE then
				finalColor = midColor
			elseif isDarkColor then
				minValue = midValue
			else
				maxValue = midValue
			end
		elseif isDarkColor then
			maxValue = midValue
		else
			minValue = midValue
		end
		if prevColor == midColor then
			break
		end
		prevColor = midColor
	end
	return finalColor or color
end

function Guide.init(maid: Maid)
	if not currentGuide then
		maid:GiveTask(Guide.new())
	end
	return nil
end

return ServiceProxy(function()
	return currentGuide or Guide
end)
